/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @ts-check

/**
 * @fileoverview Generates SVG React components for each icon.
 * N.B. we expect ../src/generated/ to contain SVG definitions of all the icons already
 * generated by fantasticon (in other words, run ./generate-icon-fonts.js first).
 */

const camelcase = require("camelcase");
const fs = require("fs");
const Handlebars = require("handlebars");
const path = require("path");
const { parse } = require("svg-parser");

const { GENERATED_SRC_DIR, COPYRIGHT_HEADER, ICON_SIZES } = require("./scriptUtils");

Handlebars.registerHelper("pascalCase", iconName => camelcase(iconName, { pascalCase: true }));
const iconComponentTemplate = Handlebars.compile(
    fs.readFileSync(path.resolve(__dirname, "iconComponent.tsx.hbs"), "utf8"),
);
const componentsIndexTemplate = Handlebars.compile(
    fs.readFileSync(path.resolve(__dirname, "componentsIndex.ts.hbs"), "utf8"),
);
const indexTemplate = Handlebars.compile(fs.readFileSync(path.resolve(__dirname, "index.ts.hbs"), "utf8"));

/** @type { { 16: {[iconName: string]: string}; 20: {[iconName: string]: string} } } */
const iconPaths = {
    [ICON_SIZES[0]]: {},
    [ICON_SIZES[1]]: {},
};

// parse icon paths from the generated SVG font
for (const iconSize of ICON_SIZES) {
    const iconFontSvgDocument = fs.readFileSync(
        path.join(GENERATED_SRC_DIR, `${iconSize}px/blueprint-icons-${iconSize}.svg`),
        "utf8",
    );

    console.info(`Parsing SVG glyphs from generated ${iconSize}px SVG icon font...`);
    parseIconGlyphs(iconFontSvgDocument, (iconName, iconPath) => {
        iconPaths[iconSize][iconName] = iconPath;
    });
    console.info(`Parsed ${Object.keys(iconPaths[iconSize]).length} ${iconSize}px icons.`);
}

// generate an ES module for each icon
console.info(`Generating ES modules for each icon...`);
fs.mkdirSync(path.join(GENERATED_SRC_DIR, `components`), { recursive: true });

for (const [iconName, icon16pxPath] of Object.entries(iconPaths[16])) {
    const icon20pxPath = iconPaths[20][iconName];
    if (icon20pxPath === undefined) {
        console.error(`Could not find corresponding 20px icon path for ${iconName}, skipping!`);
        continue;
    }
    fs.writeFileSync(
        path.join(GENERATED_SRC_DIR, `components/${iconName}.tsx`),
        iconComponentTemplate({
            iconName,
            icon16pxPath,
            icon20pxPath,
        }),
    );
}

console.info(`Writing index file for all icon modules...`);
fs.writeFileSync(
    path.join(GENERATED_SRC_DIR, `components/index.ts`),
    componentsIndexTemplate({
        iconNames: Object.keys(iconPaths[16]),
    }),
);

console.info(`Writing index file for package...`);
fs.writeFileSync(
    path.join(GENERATED_SRC_DIR, `index.ts`),
    indexTemplate({
        iconNames: Object.keys(iconPaths[16]),
    }),
);

console.info("Done.");

/**
 * Parse all icons of a given size from the SVG font generated by fantasticon.
 * At this point we've already optimized the icon SVGs through svgo (via fantasticon), so
 * we avoid duplicating that work by reading the generated glyphs here.
 *
 * @param {string} iconFontSvgDocument
 * @param {(iconName: string, iconPath: string) => void} cb iterator for each icon path
 */
function parseIconGlyphs(iconFontSvgDocument, cb) {
    const rootNode = parse(iconFontSvgDocument);
    // @ts-ignore
    const defs = rootNode.children[0].children[0];
    const glyphs = defs.children[0].children.filter(node => node.tagName === "glyph");

    for (const glyph of glyphs) {
        const name = glyph.properties["glyph-name"];

        // HACKHACK: for some reason, there are duplicates with the suffix "-1", so we ignore those
        if (name.endsWith("-1")) {
            continue;
        }

        const path = glyph.properties["d"];
        cb(name, path);
    }
}
